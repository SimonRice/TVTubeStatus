//
// PlaceAPI.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire
import RxSwift



open class PlaceAPI: APIBase {
    /**
     Gets the place with the given id.
     
     - parameter id: (path) The id of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their ids 
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGet(id: String, includeChildren: Bool? = nil, completion: @escaping ((_ data: [Place]?,_ error: Error?) -> Void)) {
        placeGetWithRequestBuilder(id: id, includeChildren: includeChildren).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets the place with the given id.
     
     - parameter id: (path) The id of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their ids 
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)
     - returns: Observable<[Place]>
     */
    open class func placeGet(id: String, includeChildren: Bool? = nil) -> Observable<[Place]> {
        return Observable.create { observer -> Disposable in
            placeGet(id: id, includeChildren: includeChildren) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets the place with the given id.
     - GET /Place/{id}
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     
     - parameter id: (path) The id of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their ids 
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)

     - returns: RequestBuilder<[Place]> 
     */
    open class func placeGetWithRequestBuilder(id: String, includeChildren: Bool? = nil) -> RequestBuilder<[Place]> {
        var path = "/Place/{id}"
        path = path.replacingOccurrences(of: "{id}", with: id.asParameter, options: .literal, range: nil)
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "includeChildren": includeChildren
        ])
        

        let requestBuilder: RequestBuilder<[Place]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets any places of the given type whose geography intersects the given latitude and longitude. In practice this means the Place              must be polygonal e.g. a BoroughBoundary.
     
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGetAt(type: [String], lat: String, lon: String, locationLat: Double, locationLon: Double, completion: @escaping ((_ data: Object?,_ error: Error?) -> Void)) {
        placeGetAtWithRequestBuilder(type: type, lat: lat, lon: lon, locationLat: locationLat, locationLon: locationLon).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets any places of the given type whose geography intersects the given latitude and longitude. In practice this means the Place              must be polygonal e.g. a BoroughBoundary.
     
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  
     - returns: Observable<Object>
     */
    open class func placeGetAt(type: [String], lat: String, lon: String, locationLat: Double, locationLon: Double) -> Observable<Object> {
        return Observable.create { observer -> Disposable in
            placeGetAt(type: type, lat: lat, lon: lon, locationLat: locationLat, locationLon: locationLon) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets any places of the given type whose geography intersects the given latitude and longitude. In practice this means the Place              must be polygonal e.g. a BoroughBoundary.
     - GET /Place/{type}/At/{lat}/{lon}
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  

     - returns: RequestBuilder<Object> 
     */
    open class func placeGetAtWithRequestBuilder(type: [String], lat: String, lon: String, locationLat: Double, locationLon: Double) -> RequestBuilder<Object> {
        var path = "/Place/{type}/At/{lat}/{lon}"
        path = path.replacingOccurrences(of: "{type}", with: type.asParameter, options: .literal, range: nil)
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "lat": lat, 
            "lon": lon, 
            "location.lat": locationLat, 
            "location.lon": locationLon
        ])
        

        let requestBuilder: RequestBuilder<Object>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets the places that lie within the bounding box defined by the lat/lon of its north-west and south-east corners. Optionally filters              on type and can strip properties for a smaller payload.
     
     - parameter bbBoxpointsSwLat: (query)  
     - parameter bbBoxpointsSwLon: (query)  
     - parameter bbBoxpointsNeLat: (query)  
     - parameter bbBoxpointsNeLon: (query)  
     - parameter categories: (query) an optional list of comma separated property categories to return in the Place&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /Place/Meta/categories endpoint) (optional)
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)
     - parameter type: (query) place types to filter on, or null to return all types (optional)
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGetByGeoBox(bbBoxpointsSwLat: Double, bbBoxpointsSwLon: Double, bbBoxpointsNeLat: Double, bbBoxpointsNeLon: Double, categories: [String]? = nil, includeChildren: Bool? = nil, type: [String]? = nil, activeOnly: Bool? = nil, completion: @escaping ((_ data: [StopPoint]?,_ error: Error?) -> Void)) {
        placeGetByGeoBoxWithRequestBuilder(bbBoxpointsSwLat: bbBoxpointsSwLat, bbBoxpointsSwLon: bbBoxpointsSwLon, bbBoxpointsNeLat: bbBoxpointsNeLat, bbBoxpointsNeLon: bbBoxpointsNeLon, categories: categories, includeChildren: includeChildren, type: type, activeOnly: activeOnly).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets the places that lie within the bounding box defined by the lat/lon of its north-west and south-east corners. Optionally filters              on type and can strip properties for a smaller payload.
     
     - parameter bbBoxpointsSwLat: (query)  
     - parameter bbBoxpointsSwLon: (query)  
     - parameter bbBoxpointsNeLat: (query)  
     - parameter bbBoxpointsNeLon: (query)  
     - parameter categories: (query) an optional list of comma separated property categories to return in the Place&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /Place/Meta/categories endpoint) (optional)
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)
     - parameter type: (query) place types to filter on, or null to return all types (optional)
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)
     - returns: Observable<[StopPoint]>
     */
    open class func placeGetByGeoBox(bbBoxpointsSwLat: Double, bbBoxpointsSwLon: Double, bbBoxpointsNeLat: Double, bbBoxpointsNeLon: Double, categories: [String]? = nil, includeChildren: Bool? = nil, type: [String]? = nil, activeOnly: Bool? = nil) -> Observable<[StopPoint]> {
        return Observable.create { observer -> Disposable in
            placeGetByGeoBox(bbBoxpointsSwLat: bbBoxpointsSwLat, bbBoxpointsSwLon: bbBoxpointsSwLon, bbBoxpointsNeLat: bbBoxpointsNeLat, bbBoxpointsNeLon: bbBoxpointsNeLon, categories: categories, includeChildren: includeChildren, type: type, activeOnly: activeOnly) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets the places that lie within the bounding box defined by the lat/lon of its north-west and south-east corners. Optionally filters              on type and can strip properties for a smaller payload.
     - GET /Place
     - examples: [{contentType=application/json, example=[ {
  "indicator" : "aeiou",
  "commonName" : "aeiou",
  "modes" : [ "aeiou" ],
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "smsCode" : "aeiou",
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ {
    "commonName" : "aeiou",
    "placeType" : "aeiou",
    "distance" : 1.3579000000000001069366817318950779736042022705078125,
    "children" : [ "" ],
    "childrenUrls" : [ "aeiou" ],
    "lon" : 1.3579000000000001069366817318950779736042022705078125,
    "id" : "aeiou",
    "additionalProperties" : [ "" ],
    "url" : "aeiou",
    "lat" : 1.3579000000000001069366817318950779736042022705078125
  } ],
  "hubNaptanCode" : "aeiou",
  "stopLetter" : "aeiou",
  "id" : "aeiou",
  "platformName" : "aeiou",
  "lines" : [ {
    "crowding" : {
      "trainLoadings" : [ {
        "naptanTo" : "aeiou",
        "line" : "aeiou",
        "timeSlice" : "aeiou",
        "platformDirection" : "aeiou",
        "value" : 123,
        "lineDirection" : "aeiou",
        "direction" : "aeiou"
      } ],
      "passengerFlows" : [ {
        "timeSlice" : "aeiou",
        "value" : 123
      } ]
    },
    "name" : "aeiou",
    "fullName" : "aeiou",
    "id" : "aeiou",
    "type" : "aeiou",
    "uri" : "aeiou"
  } ],
  "lat" : 1.3579000000000001069366817318950779736042022705078125,
  "lineModeGroups" : [ {
    "modeName" : "aeiou",
    "lineIdentifier" : [ "aeiou" ]
  } ],
  "childrenUrls" : [ "aeiou" ],
  "stationNaptan" : "aeiou",
  "fullName" : "aeiou",
  "stopType" : "aeiou",
  "naptanMode" : "aeiou",
  "url" : "aeiou",
  "placeType" : "aeiou",
  "naptanId" : "aeiou",
  "icsCode" : "aeiou",
  "lineGroup" : [ {
    "naptanIdReference" : "aeiou",
    "lineIdentifier" : [ "aeiou" ],
    "stationAtcoCode" : "aeiou"
  } ],
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "accessibilitySummary" : "aeiou",
  "status" : true
} ]}, {contentType=application/xml, example=<null>
  <naptanId>aeiou</naptanId>
  <platformName>aeiou</platformName>
  <indicator>aeiou</indicator>
  <stopLetter>aeiou</stopLetter>
  <modes>aeiou</modes>
  <icsCode>aeiou</icsCode>
  <smsCode>aeiou</smsCode>
  <stopType>aeiou</stopType>
  <stationNaptan>aeiou</stationNaptan>
  <accessibilitySummary>aeiou</accessibilitySummary>
  <hubNaptanCode>aeiou</hubNaptanCode>
  <fullName>aeiou</fullName>
  <naptanMode>aeiou</naptanMode>
  <status>true</status>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "indicator" : "aeiou",
  "commonName" : "aeiou",
  "modes" : [ "aeiou" ],
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "smsCode" : "aeiou",
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ {
    "commonName" : "aeiou",
    "placeType" : "aeiou",
    "distance" : 1.3579000000000001069366817318950779736042022705078125,
    "children" : [ "" ],
    "childrenUrls" : [ "aeiou" ],
    "lon" : 1.3579000000000001069366817318950779736042022705078125,
    "id" : "aeiou",
    "additionalProperties" : [ "" ],
    "url" : "aeiou",
    "lat" : 1.3579000000000001069366817318950779736042022705078125
  } ],
  "hubNaptanCode" : "aeiou",
  "stopLetter" : "aeiou",
  "id" : "aeiou",
  "platformName" : "aeiou",
  "lines" : [ {
    "crowding" : {
      "trainLoadings" : [ {
        "naptanTo" : "aeiou",
        "line" : "aeiou",
        "timeSlice" : "aeiou",
        "platformDirection" : "aeiou",
        "value" : 123,
        "lineDirection" : "aeiou",
        "direction" : "aeiou"
      } ],
      "passengerFlows" : [ {
        "timeSlice" : "aeiou",
        "value" : 123
      } ]
    },
    "name" : "aeiou",
    "fullName" : "aeiou",
    "id" : "aeiou",
    "type" : "aeiou",
    "uri" : "aeiou"
  } ],
  "lat" : 1.3579000000000001069366817318950779736042022705078125,
  "lineModeGroups" : [ {
    "modeName" : "aeiou",
    "lineIdentifier" : [ "aeiou" ]
  } ],
  "childrenUrls" : [ "aeiou" ],
  "stationNaptan" : "aeiou",
  "fullName" : "aeiou",
  "stopType" : "aeiou",
  "naptanMode" : "aeiou",
  "url" : "aeiou",
  "placeType" : "aeiou",
  "naptanId" : "aeiou",
  "icsCode" : "aeiou",
  "lineGroup" : [ {
    "naptanIdReference" : "aeiou",
    "lineIdentifier" : [ "aeiou" ],
    "stationAtcoCode" : "aeiou"
  } ],
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "accessibilitySummary" : "aeiou",
  "status" : true
} ]}, {contentType=application/xml, example=<null>
  <naptanId>aeiou</naptanId>
  <platformName>aeiou</platformName>
  <indicator>aeiou</indicator>
  <stopLetter>aeiou</stopLetter>
  <modes>aeiou</modes>
  <icsCode>aeiou</icsCode>
  <smsCode>aeiou</smsCode>
  <stopType>aeiou</stopType>
  <stationNaptan>aeiou</stationNaptan>
  <accessibilitySummary>aeiou</accessibilitySummary>
  <hubNaptanCode>aeiou</hubNaptanCode>
  <fullName>aeiou</fullName>
  <naptanMode>aeiou</naptanMode>
  <status>true</status>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     
     - parameter bbBoxpointsSwLat: (query)  
     - parameter bbBoxpointsSwLon: (query)  
     - parameter bbBoxpointsNeLat: (query)  
     - parameter bbBoxpointsNeLon: (query)  
     - parameter categories: (query) an optional list of comma separated property categories to return in the Place&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /Place/Meta/categories endpoint) (optional)
     - parameter includeChildren: (query) Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned (optional)
     - parameter type: (query) place types to filter on, or null to return all types (optional)
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)

     - returns: RequestBuilder<[StopPoint]> 
     */
    open class func placeGetByGeoBoxWithRequestBuilder(bbBoxpointsSwLat: Double, bbBoxpointsSwLon: Double, bbBoxpointsNeLat: Double, bbBoxpointsNeLon: Double, categories: [String]? = nil, includeChildren: Bool? = nil, type: [String]? = nil, activeOnly: Bool? = nil) -> RequestBuilder<[StopPoint]> {
        let path = "/Place"
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "categories": categories, 
            "includeChildren": includeChildren, 
            "type": type, 
            "activeOnly": activeOnly, 
            "bbBoxpoints.swLat": bbBoxpointsSwLat, 
            "bbBoxpoints.swLon": bbBoxpointsSwLon, 
            "bbBoxpoints.neLat": bbBoxpointsNeLat, 
            "bbBoxpoints.neLon": bbBoxpointsNeLon
        ])
        

        let requestBuilder: RequestBuilder<[StopPoint]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets all places of a given type
     
     - parameter types: (path) A comma-separated list of the types to return. Max. approx 12 types.              A valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint. 
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGetByType(types: [String], activeOnly: Bool? = nil, completion: @escaping ((_ data: [Place]?,_ error: Error?) -> Void)) {
        placeGetByTypeWithRequestBuilder(types: types, activeOnly: activeOnly).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets all places of a given type
     
     - parameter types: (path) A comma-separated list of the types to return. Max. approx 12 types.              A valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint. 
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)
     - returns: Observable<[Place]>
     */
    open class func placeGetByType(types: [String], activeOnly: Bool? = nil) -> Observable<[Place]> {
        return Observable.create { observer -> Disposable in
            placeGetByType(types: types, activeOnly: activeOnly) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets all places of a given type
     - GET /Place/Type/{types}
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     
     - parameter types: (path) A comma-separated list of the types to return. Max. approx 12 types.              A valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint. 
     - parameter activeOnly: (query) An optional parameter to limit the results to active records only (Currently only the &#39;VariableMessageSign&#39; place type is supported) (optional)

     - returns: RequestBuilder<[Place]> 
     */
    open class func placeGetByTypeWithRequestBuilder(types: [String], activeOnly: Bool? = nil) -> RequestBuilder<[Place]> {
        var path = "/Place/Type/{types}"
        path = path.replacingOccurrences(of: "{types}", with: types.asParameter, options: .literal, range: nil)
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "activeOnly": activeOnly
        ])
        

        let requestBuilder: RequestBuilder<[Place]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets the place overlay for a given set of co-ordinates and a given width/height.
     
     - parameter z: (path) The zoom level 
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter width: (path) The width of the requested overlay. 
     - parameter height: (path) The height of the requested overlay. 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGetOverlay(z: Int32, type: [String], width: Int32, height: Int32, lat: String, lon: String, locationLat: Double, locationLon: Double, completion: @escaping ((_ data: Object?,_ error: Error?) -> Void)) {
        placeGetOverlayWithRequestBuilder(z: z, type: type, width: width, height: height, lat: lat, lon: lon, locationLat: locationLat, locationLon: locationLon).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets the place overlay for a given set of co-ordinates and a given width/height.
     
     - parameter z: (path) The zoom level 
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter width: (path) The width of the requested overlay. 
     - parameter height: (path) The height of the requested overlay. 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  
     - returns: Observable<Object>
     */
    open class func placeGetOverlay(z: Int32, type: [String], width: Int32, height: Int32, lat: String, lon: String, locationLat: Double, locationLon: Double) -> Observable<Object> {
        return Observable.create { observer -> Disposable in
            placeGetOverlay(z: z, type: type, width: width, height: height, lat: lat, lon: lon, locationLat: locationLat, locationLon: locationLon) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets the place overlay for a given set of co-ordinates and a given width/height.
     - GET /Place/{type}/overlay/{z}/{lat}/{lon}/{width}/{height}
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     
     - parameter z: (path) The zoom level 
     - parameter type: (path) The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint) 
     - parameter width: (path) The width of the requested overlay. 
     - parameter height: (path) The height of the requested overlay. 
     - parameter lat: (query)  
     - parameter lon: (query)  
     - parameter locationLat: (query)  
     - parameter locationLon: (query)  

     - returns: RequestBuilder<Object> 
     */
    open class func placeGetOverlayWithRequestBuilder(z: Int32, type: [String], width: Int32, height: Int32, lat: String, lon: String, locationLat: Double, locationLon: Double) -> RequestBuilder<Object> {
        var path = "/Place/{type}/overlay/{z}/{lat}/{lon}/{width}/{height}"
        path = path.replacingOccurrences(of: "{z}", with: z.asParameter, options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{type}", with: type.asParameter, options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{width}", with: width.asParameter, options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{height}", with: height.asParameter, options: .literal, range: nil)
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "lat": lat, 
            "lon": lon, 
            "location.lat": locationLat, 
            "location.lon": locationLon
        ])
        

        let requestBuilder: RequestBuilder<Object>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets the set of streets associated with a post code.
     
     - parameter postcode: (query)  
     - parameter postcodeInputPostcode: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeGetStreetsByPostCode(postcode: String, postcodeInputPostcode: String? = nil, completion: @escaping ((_ data: Object?,_ error: Error?) -> Void)) {
        placeGetStreetsByPostCodeWithRequestBuilder(postcode: postcode, postcodeInputPostcode: postcodeInputPostcode).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets the set of streets associated with a post code.
     
     - parameter postcode: (query)  
     - parameter postcodeInputPostcode: (query)  (optional)
     - returns: Observable<Object>
     */
    open class func placeGetStreetsByPostCode(postcode: String, postcodeInputPostcode: String? = nil) -> Observable<Object> {
        return Observable.create { observer -> Disposable in
            placeGetStreetsByPostCode(postcode: postcode, postcodeInputPostcode: postcodeInputPostcode) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets the set of streets associated with a post code.
     - GET /Place/Address/Streets/{postcode}
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     - examples: [{contentType=application/json, example={ }}, {contentType=application/xml, example=<null>
</null>}]
     
     - parameter postcode: (query)  
     - parameter postcodeInputPostcode: (query)  (optional)

     - returns: RequestBuilder<Object> 
     */
    open class func placeGetStreetsByPostCodeWithRequestBuilder(postcode: String, postcodeInputPostcode: String? = nil) -> RequestBuilder<Object> {
        let path = "/Place/Address/Streets/{postcode}"
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "postcode": postcode, 
            "postcodeInput.postcode": postcodeInputPostcode
        ])
        

        let requestBuilder: RequestBuilder<Object>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets a list of all of the available place property categories and keys.
     
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeMetaCategories(completion: @escaping ((_ data: [PlaceCategory]?,_ error: Error?) -> Void)) {
        placeMetaCategoriesWithRequestBuilder().execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets a list of all of the available place property categories and keys.
     
     - returns: Observable<[PlaceCategory]>
     */
    open class func placeMetaCategories() -> Observable<[PlaceCategory]> {
        return Observable.create { observer -> Disposable in
            placeMetaCategories() { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets a list of all of the available place property categories and keys.
     - GET /Place/Meta/Categories
     - examples: [{contentType=application/json, example=[ {
  "category" : "aeiou",
  "availableKeys" : [ "aeiou" ]
} ]}, {contentType=application/xml, example=<null>
  <category>aeiou</category>
  <availableKeys>aeiou</availableKeys>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "category" : "aeiou",
  "availableKeys" : [ "aeiou" ]
} ]}, {contentType=application/xml, example=<null>
  <category>aeiou</category>
  <availableKeys>aeiou</availableKeys>
</null>}]

     - returns: RequestBuilder<[PlaceCategory]> 
     */
    open class func placeMetaCategoriesWithRequestBuilder() -> RequestBuilder<[PlaceCategory]> {
        let path = "/Place/Meta/Categories"
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<[PlaceCategory]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets a list of the available types of Place.
     
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeMetaPlaceTypes(completion: @escaping ((_ data: [PlaceCategory]?,_ error: Error?) -> Void)) {
        placeMetaPlaceTypesWithRequestBuilder().execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets a list of the available types of Place.
     
     - returns: Observable<[PlaceCategory]>
     */
    open class func placeMetaPlaceTypes() -> Observable<[PlaceCategory]> {
        return Observable.create { observer -> Disposable in
            placeMetaPlaceTypes() { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets a list of the available types of Place.
     - GET /Place/Meta/PlaceTypes
     - examples: [{contentType=application/json, example=[ {
  "category" : "aeiou",
  "availableKeys" : [ "aeiou" ]
} ]}, {contentType=application/xml, example=<null>
  <category>aeiou</category>
  <availableKeys>aeiou</availableKeys>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "category" : "aeiou",
  "availableKeys" : [ "aeiou" ]
} ]}, {contentType=application/xml, example=<null>
  <category>aeiou</category>
  <availableKeys>aeiou</availableKeys>
</null>}]

     - returns: RequestBuilder<[PlaceCategory]> 
     */
    open class func placeMetaPlaceTypesWithRequestBuilder() -> RequestBuilder<[PlaceCategory]> {
        let path = "/Place/Meta/PlaceTypes"
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<[PlaceCategory]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Gets all places that matches the given query
     
     - parameter name: (query) The name of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their names. 
     - parameter types: (query) A comma-separated list of the types to return. Max. approx 12 types. (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func placeSearch(name: String, types: [String]? = nil, completion: @escaping ((_ data: [Place]?,_ error: Error?) -> Void)) {
        placeSearchWithRequestBuilder(name: name, types: types).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     Gets all places that matches the given query
     
     - parameter name: (query) The name of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their names. 
     - parameter types: (query) A comma-separated list of the types to return. Max. approx 12 types. (optional)
     - returns: Observable<[Place]>
     */
    open class func placeSearch(name: String, types: [String]? = nil) -> Observable<[Place]> {
        return Observable.create { observer -> Disposable in
            placeSearch(name: name, types: types) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     Gets all places that matches the given query
     - GET /Place/Search
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     - examples: [{contentType=application/json, example=[ {
  "commonName" : "aeiou",
  "placeType" : "aeiou",
  "distance" : 1.3579000000000001069366817318950779736042022705078125,
  "children" : [ "" ],
  "childrenUrls" : [ "aeiou" ],
  "lon" : 1.3579000000000001069366817318950779736042022705078125,
  "id" : "aeiou",
  "additionalProperties" : [ {
    "sourceSystemKey" : "aeiou",
    "modified" : "2000-01-23T04:56:07.000+00:00",
    "category" : "aeiou",
    "value" : "aeiou",
    "key" : "aeiou"
  } ],
  "url" : "aeiou",
  "lat" : 1.3579000000000001069366817318950779736042022705078125
} ]}, {contentType=application/xml, example=<null>
  <id>aeiou</id>
  <url>aeiou</url>
  <commonName>aeiou</commonName>
  <distance>3.149</distance>
  <placeType>aeiou</placeType>
  <childrenUrls>aeiou</childrenUrls>
  <lat>3.149</lat>
  <lon>3.149</lon>
</null>}]
     
     - parameter name: (query) The name of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their names. 
     - parameter types: (query) A comma-separated list of the types to return. Max. approx 12 types. (optional)

     - returns: RequestBuilder<[Place]> 
     */
    open class func placeSearchWithRequestBuilder(name: String, types: [String]? = nil) -> RequestBuilder<[Place]> {
        let path = "/Place/Search"
        let URLString = RxTfLAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "name": name, 
            "types": types
        ])
        

        let requestBuilder: RequestBuilder<[Place]>.Type = RxTfLAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

}
