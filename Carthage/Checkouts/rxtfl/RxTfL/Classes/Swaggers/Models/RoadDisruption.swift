//
// RoadDisruption.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


open class RoadDisruption: JSONEncodable {

    /** Unique identifier for the road disruption */
    public var id: String?
    /** URL to retrieve this road disruption */
    public var url: String?
    /** Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string. */
    public var point: String?
    /** A description of the severity of the disruption. */
    public var severity: String?
    /** An ordinal of the disruption based on severity, level of interest and corridor. */
    public var ordinal: Int32?
    /** Describes the nature of disruption e.g. Traffic Incidents, Works */
    public var category: String?
    /** Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load */
    public var subCategory: String?
    /** Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate. */
    public var comments: String?
    /** Text of the most recent update from the LSTCC on the state of the               disruption, including the current traffic impact and any advice to               road users. */
    public var currentUpdate: String?
    /** The time when the last CurrentUpdate description was recorded,               or null if no CurrentUpdate has been applied. */
    public var currentUpdateDateTime: Date?
    /** The Ids of affected corridors, if any. */
    public var corridorIds: [String]?
    /** The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.              For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator. */
    public var startDateTime: Date?
    /** The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned               disruptions in progress, this field will be omitted. */
    public var endDateTime: Date?
    /** The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly              compare two instances of the same disruption to determine if it has been changed. */
    public var lastModifiedTime: Date?
    /** This describes the level of potential impact on traffic operations of the disruption.               High &#x3D; e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention               Medium &#x3D; This is the default value               Low &#x3D; e.g. a frequently occurring disruption which is well known */
    public var levelOfInterest: String?
    /** Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited. */
    public var location: String?
    /** This describes the status of the disruption.                Active &#x3D; currently in progress               Active Long Term &#x3D; currently in progress and long term              Scheduled &#x3D; scheduled to start within the next 180 days              Recurring Works &#x3D; planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.              Recently Cleared &#x3D; recently cleared in the last 24 hours              Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end. */
    public var status: String?
    /** Geography version of Point for output as GeoJSON.              Can not use Geometry in a consistent way as non-TIMS disruptions do not have a polygon */
    public var geography: DbGeography?
    /** GeoJSON formatted latitude/longitude (WGS84) pairs forming an enclosed polyline or polygon. The polygon will only be included where affected streets information              is not available for the disruption, would be inappropriate (e.g. a very large number of streets), or is centred on an area without streets (e.g. a football stadium). */
    public var geometry: DbGeography?
    /** A collection of zero or more streets affected by the disruption. */
    public var streets: [Street]?
    /** True if the disruption is planned on a future date that is open to change */
    public var isProvisional: Bool?
    /** True if any of the affected Streets have a \&quot;Full Closure\&quot; status, false otherwise. A RoadDisruption that has HasClosures is considered a               Severe or Serious disruption for severity filtering purposes. */
    public var hasClosures: Bool?
    /** The text of any associated link */
    public var linkText: String?
    /** The url of any associated link */
    public var linkUrl: String?
    /** Any associated road project */
    public var roadProject: RoadProject?
    /** TDM Additional properties */
    public var publishStartDate: Date?
    public var publishEndDate: Date?
    public var timeFrame: String?
    public var roadDisruptionLines: [RoadDisruptionLine]?
    public var roadDisruptionImpactAreas: [RoadDisruptionImpactArea]?
    public var recurringSchedules: [RoadDisruptionSchedule]?

    public init() {}

    // MARK: JSONEncodable
    open func encodeToJSON() -> Any {
        var nillableDictionary = [String:Any?]()
        nillableDictionary["id"] = self.id
        nillableDictionary["url"] = self.url
        nillableDictionary["point"] = self.point
        nillableDictionary["severity"] = self.severity
        nillableDictionary["ordinal"] = self.ordinal?.encodeToJSON()
        nillableDictionary["category"] = self.category
        nillableDictionary["subCategory"] = self.subCategory
        nillableDictionary["comments"] = self.comments
        nillableDictionary["currentUpdate"] = self.currentUpdate
        nillableDictionary["currentUpdateDateTime"] = self.currentUpdateDateTime?.encodeToJSON()
        nillableDictionary["corridorIds"] = self.corridorIds?.encodeToJSON()
        nillableDictionary["startDateTime"] = self.startDateTime?.encodeToJSON()
        nillableDictionary["endDateTime"] = self.endDateTime?.encodeToJSON()
        nillableDictionary["lastModifiedTime"] = self.lastModifiedTime?.encodeToJSON()
        nillableDictionary["levelOfInterest"] = self.levelOfInterest
        nillableDictionary["location"] = self.location
        nillableDictionary["status"] = self.status
        nillableDictionary["geography"] = self.geography?.encodeToJSON()
        nillableDictionary["geometry"] = self.geometry?.encodeToJSON()
        nillableDictionary["streets"] = self.streets?.encodeToJSON()
        nillableDictionary["isProvisional"] = self.isProvisional
        nillableDictionary["hasClosures"] = self.hasClosures
        nillableDictionary["linkText"] = self.linkText
        nillableDictionary["linkUrl"] = self.linkUrl
        nillableDictionary["roadProject"] = self.roadProject?.encodeToJSON()
        nillableDictionary["publishStartDate"] = self.publishStartDate?.encodeToJSON()
        nillableDictionary["publishEndDate"] = self.publishEndDate?.encodeToJSON()
        nillableDictionary["timeFrame"] = self.timeFrame
        nillableDictionary["roadDisruptionLines"] = self.roadDisruptionLines?.encodeToJSON()
        nillableDictionary["roadDisruptionImpactAreas"] = self.roadDisruptionImpactAreas?.encodeToJSON()
        nillableDictionary["recurringSchedules"] = self.recurringSchedules?.encodeToJSON()

        let dictionary: [String:Any] = APIHelper.rejectNil(nillableDictionary) ?? [:]
        return dictionary
    }
}
